<script>
(() => {
  const $ = (id) => document.getElementById(id);
  const fmtTime = (s) => {
    if (!isFinite(s) || s <= 0) return "0:00";
    const m = Math.floor(s / 60);
    const r = Math.floor(s % 60);
    return `${m}:${String(r).padStart(2,"0")}`;
  };

  // ✅ BOTH tracks, with smart filename fallbacks
  const TRACKS = [
    {
      label: "You Ain’t Static…",
      title: "You Ain’t Static… You Signal",
      candidates: [
        "You Ain’t Static You Signal.mp3",
        "You Ain't Static You Signal.mp3",
        "You Aint Static You Signal.mp3",
        "You_Aint_Static_You_Signal.mp3",
        "You-Aint-Static-You-Signal.mp3"
      ]
    },
    {
      label: "You Signal 2",
      title: "You Ain’t Static… You Signal 2",
      candidates: [
        "You Ain’t Static You Signal 2.mp3",
        "You Ain't Static You Signal 2.mp3",
        "You Aint Static You Signal 2.mp3",
        "You_Aint_Static_You_Signal_2.mp3",
        "You-Aint-Static-You-Signal-2.mp3"
      ]
    }
  ];

  // Elements (matches your existing IDs)
  const audio = $("audio");
  const btnPlay = $("btnPlay");
  const btnStop = $("btnStop");
  const btnPrev = $("btnPrev");
  const btnRew  = $("btnRew");
  const btnFwd  = $("btnFwd");
  const btnShare = $("btnShare");
  const overlay = $("overlay");
  const btnStart = $("btnStart");
  const pageTitle = $("pageTitle");
  const trackSub = $("trackSub");
  const trackIdx = $("trackIdx");
  const statusText = $("statusText");
  const tNow = $("tNow");
  const tDur = $("tDur");
  const seek = $("seek");
  const t1 = $("t1");
  const t2 = $("t2");

  let currentIndex = 0;
  let playing = false;
  let seeking = false;

  function setTrackButtons(){
    t1.classList.toggle("active", currentIndex === 0);
    t2.classList.toggle("active", currentIndex === 1);
    trackIdx.textContent = `${currentIndex+1} / ${TRACKS.length}`;
    t1.textContent = TRACKS[0].label;
    t2.textContent = TRACKS[1].label;
  }

  async function startAudio(){
    overlay.classList.remove("show");
  }

  // Build a safe URL for a filename (handles unicode/spaces)
  function urlFor(name){
    // encode each segment, but keep slashes (if any)
    return name.split("/").map(encodeURIComponent).join("/");
  }

  // Try each candidate until one exists
  async function resolveCandidate(candidates){
    for (const name of candidates){
      const u = urlFor(name);
      try{
        // GitHub Pages supports GET; use a small-range request to avoid downloading all
        const r = await fetch(u, { method:"GET", headers: { "Range":"bytes=0-1" } });
        if (r.ok || r.status === 206) return u;
      }catch{}
    }
    return null;
  }

  async function loadTrack(idx, {autoplay=false}={}){
    currentIndex = (idx + TRACKS.length) % TRACKS.length;
    setTrackButtons();

    const track = TRACKS[currentIndex];
    statusText.textContent = "LOADING";

    const resolved = await resolveCandidate(track.candidates);

    if (!resolved){
      statusText.textContent = "FILE MISSING";
      pageTitle.textContent = track.title;
      btnPlay.textContent = "▶︎";
      playing = false;
      return;
    }

    audio.src = resolved;
    audio.load();

    pageTitle.textContent = track.title;
    trackSub.textContent = "SwampHop Mystic";
    statusText.textContent = "LOADED";

    if (autoplay){
      await startAudio();
      try{
        await audio.play();
        playing = true;
        btnPlay.textContent = "⏸︎";
        statusText.textContent = "LIVE";
      }catch{
        playing = false;
        btnPlay.textContent = "▶︎";
        statusText.textContent = "TAP ▶︎";
      }
    } else {
      playing = false;
      btnPlay.textContent = "▶︎";
    }
  }

  // UI wiring
  btnStart.addEventListener("click", async () => {
    await startAudio();
    if (!audio.src) await loadTrack(0, {autoplay:false});
  });

  btnPlay.addEventListener("click", async () => {
    if (!audio.src) await loadTrack(0, {autoplay:false});
    await startAudio();

    if (audio.paused){
      try{
        await audio.play();
        playing = true;
        btnPlay.textContent = "⏸︎";
        statusText.textContent = "LIVE";
      }catch{
        statusText.textContent = "TAP AGAIN";
      }
    } else {
      audio.pause();
      playing = false;
      btnPlay.textContent = "▶︎";
      statusText.textContent = "PAUSED";
    }
  });

  btnStop.addEventListener("click", () => {
    if (!audio.src) return;
    audio.pause();
    audio.currentTime = 0;
    playing = false;
    btnPlay.textContent = "▶︎";
    statusText.textContent = "STOP";
  });

  btnPrev.addEventListener("click", async () => loadTrack(currentIndex - 1, {autoplay:true}));
  btnRew.addEventListener("click", () => { if (audio.src) audio.currentTime = Math.max(0, audio.currentTime - 10); });
  btnFwd.addEventListener("click", () => { if (audio.src) audio.currentTime = Math.min(audio.duration || 0, audio.currentTime + 10); });

  t1.addEventListener("click", () => loadTrack(0, {autoplay:true}));
  t2.addEventListener("click", () => loadTrack(1, {autoplay:true}));

  btnShare.addEventListener("click", async () => {
    const url = new URL(location.href);
    url.searchParams.set("track", String(currentIndex));
    try{
      await navigator.clipboard.writeText(url.toString());
      statusText.textContent = "COPIED";
    }catch{
      statusText.textContent = "NO CLIP";
    }
    setTimeout(()=> statusText.textContent = playing ? "LIVE" : "IDLE", 900);
  });

  // Seek/time
  seek.addEventListener("input", () => {
    if (!audio.duration) return;
    seeking = true;
    const pct = parseInt(seek.value,10)/1000;
    tNow.textContent = fmtTime(pct * audio.duration);
  });
  seek.addEventListener("change", () => {
    if (!audio.duration) return;
    const pct = parseInt(seek.value,10)/1000;
    audio.currentTime = pct * audio.duration;
    seeking = false;
  });

  audio.addEventListener("loadedmetadata", () => tDur.textContent = fmtTime(audio.duration));
  audio.addEventListener("timeupdate", () => {
    if (!audio.duration) return;
    if (!seeking){
      tNow.textContent = fmtTime(audio.currentTime);
      seek.value = String(Math.floor((audio.currentTime / audio.duration) * 1000));
    }
  });
  audio.addEventListener("ended", async () => {
    playing = false;
    btnPlay.textContent = "▶︎";
    statusText.textContent = "END";
  });

  // init
  setTrackButtons();
  const qs = new URLSearchParams(location.search);
  const qTrack = parseInt(qs.get("track") || "0", 10);
  loadTrack(Number.isFinite(qTrack) ? qTrack : 0, {autoplay:false});
})();
</script>
